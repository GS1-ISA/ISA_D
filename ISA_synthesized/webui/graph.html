<!doctype html>
<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ISA â€” Graph Explorer</title><link rel="stylesheet" href="/static/tokens.css"><link rel="stylesheet" href="/static/styles.css">
<style>#c{width:100%;height:72vh;border:1px solid var(--line);border-radius:12px;background:#fff;}</style></head>
<body><div class="topbar"><div class="wrap"><strong>Graph Explorer</strong> <a href="/ui/users" style="margin-left:12px">Back</a></div></div>
<div class="wrap"><div class="row"><input id="filter" placeholder="filter nodes..."/><button id="refresh">Refresh</button></div><canvas id="c"></canvas><pre id="info"></pre></div>
<script>
function esc(s){return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');}
async function load(){const d = await (await fetch('/graph')).json();draw(d);}
function draw(g){
  const nodes = Object.keys(g.entities).map((k,i)=>({id:k, type=g.entities[k].type, x: Math.random()*600+80, y: Math.random()*320+80, vx:0, vy:0}));
  const edges = (g.relations||[]).map(r=>({s:r.subject, o:r.object}));
  const id2 = Object.fromEntries(nodes.map(n=>[n.id,n]));
  const W = document.getElementById('c').clientWidth, H = document.getElementById('c').clientHeight;
  const canvas = document.getElementById('c'); const ctx = canvas.getContext('2d'); canvas.width=W; canvas.height=H;
  function step(){
    for (let i=0;i<nodes.length;i++){
      for (let j=i+1;j<nodes.length;j++){
        const a=nodes[i], b=nodes[j]; const dx=a.x-b.x, dy=a.y-b.y; const d=Math.hypot(dx,dy)+0.1; const rep=600/(d*d);
        a.vx += (dx/d)*rep; a.vy += (dy/d)*rep; b.vx -= (dx/d)*rep; b.vy -= (dy/d)*rep;
      }
    }
    for (const e of edges){
      const a=id2[e.s], b=id2[e.o]; if(!a||!b) continue; const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy)+0.1; const k=0.01*(d-140);
      a.vx += dx/d*k; a.vy += dy/d*k; b.vx -= dx/d*k; b.vy -= dy/d*k;
    }
    for (const n of nodes){
      n.vx*=0.9; n.vy*=0.9; n.x+=n.vx; n.y+=n.vy; n.x=Math.max(30,Math.min(W-30,n.x)); n.y=Math.max(30,Math.min(H-30,n.y));
    }
  }
  function render(filt){
    ctx.clearRect(0,0,W,H);
    ctx.strokeStyle="#d1d5db"; ctx.globalAlpha=0.8;
    for (const e of edges){
      const a=id2[e.s], b=id2[e.o]; if(!a||!b) continue;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }
    ctx.globalAlpha=1.0;
    for (const n of nodes){
      if (filt && !n.id.toLowerCase().includes(filt)) continue;
      ctx.beginPath(); ctx.fillStyle="#3b82f6"; ctx.arc(n.x,n.y,8,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#111827"; ctx.font="12px system-ui"; ctx.fillText(n.id, n.x+10, n.y+4);
    }
  }
  let last=0, filt="";
  function loop(ts){ if (ts-last>16){ step(); render(filt); last=ts; } requestAnimationFrame(loop); }
  loop(0);
  document.getElementById('filter').oninput=(e)=>{filt=e.target.value.toLowerCase();};
}
document.getElementById('refresh').onclick=load; load();
</script>
</body></html>
